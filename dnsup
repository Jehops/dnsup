#!/bin/sh
#
# SPDX-License-Identifier: BSD-2-Clause
#
# Copyright (c) 2016-2025, Joe Mingrone.
#

# dnsup - DNS Updater
#
# Run dnsup -h or visit https://github.com/Jehops/dnsup for an overview.
#

fatal ()
{
    printf "[%s] FATAL: %s.\n" "$(date)" "$*" >&2

    exit 1
}

help () {
    version=0.5.1

    cat <<EOF
NAME
   ${0##*/} -- DNS Updater

SYNOPSIS
   ${0##*/} [-h|-s]

DESCRIPTION
   Update a host's A record when its external IPv4 address changes.  The update
   is performed using a DNS provider's API.  Gandi and Porkbun are supported.

   -h   Print this help message.
   -s   Be silent except upon error.

   A configuration file, typically named <domain>.<record>.conf (e.g.,
   home.example.com.conf), is read from /etc/dnsup/ or /usr/local/etc/dnsup/ for
   each A record to be updated.

   Configuration values

   Common:
   provider=<Gandi | Porkbun>
   domain=<domain name>
   name=<Use @ or leave blank for zone root, otherwise subdomain without domain>
   ttl=<TTL in seconds, minimum of 600 for Porkbun>

   Gandi:
   pat=<Personal Access Token>

   Porkbun:
   apikey=<API key>
   secretapikey=<secret API key>

   To learn about the API keys and configuration values specific to each
   provider, visit these sites.

   Gandi: https://api.gandi.net/
   Porkbun: https://porkbun.com/account/api

COMPATIBILITY
   ${0##*/} is written in POSIX shell.  It requires curl with TLS support and a
   CA certificate store.

EXAMPLE
   $ cat /usr/local/etc/dnsup/example.com.conf

   provider=porkbun
   domain=example.com
   apikey=pk1_5c7a9e0f3b1d4862a9c3e5f0d1b476823a5d9c1f0b4e72638d50f91a2c3b4e7d
   secretapikey=sk1_f8b3a0e5c7d19246b0e9d5f7c1a83429e6f0d3b5c7a19284f6e3d5c7a0b1d4e9
   ttl=600

   $ cat /usr/local/etc/cron.d/dnsup

   PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin
   SHELL=/bin/sh

   #minute  hour  mday  month  wday  who    command
   */5      *     *     *      *     dnsup  dnsup >> /var/log/dnsup.log 2>&1
   @reboot                           dnsup  dnsup >> /var/log/dnsup.log 2>&1

AUTHOR
Joe Mingrone <jrm@ftfl.ca>

VERSION
   ${0##*/} version ${version}

EOF
    exit 0
}

url_encode() {
    # Encode all characters except alphanumerics and -._~
    old_lc_collate=$LC_COLLATE
    LC_COLLATE=C
    input=$1
    encoded=""
    i=1
    len=$(printf "%s" "$input" | wc -c)
    while [ "$i" -le "$len" ]; do
	c=$(printf "%s" "$input" | cut -c $i)
	case "$c" in
	    [a-zA-Z0-9.~_-]) encoded="${encoded}${c}" ;;
            *) encoded="${encoded}$(printf '%%%02X' "'$c")" ;;
        esac
        i=$((i + 1))
    done

    if [ -n "$old_lc_collate" ]; then
        LC_COLLATE="$old_lc_collate"
    else
        LC_COLLATE=C
    fi

    printf "%s" "$encoded"
}

 myip () {
     host myip.opendns.com resolver1.opendns.com | \
         awk '/^myip.opendns.com has address / {print $4}'
 }

 gandi () {
     api='https://api.gandi.net/v5/livedns/domains/'

     resp=$(curl --connect-timeout 10 --max-time 30 -L -s -X PUT \
                 -H "Authorization: Bearer $pat" \
                 -H "Content-type: application/json" \
                 -d '{"rrset_values": ["'"$ipv4"'"],"rrset_ttl": '"${ttl}"'}' \
                 "${api}${domain}/records/${name}/A")

     printf "%s" "$resp" | grep -q '"message":"DNS Record'
 }

 porkbun () {
     enc_domain=$(url_encode "${domain}")
     enc_name=$(url_encode "${name}")
     api="https://api.porkbun.com/api/json/v3/dns/editByNameType/${enc_domain}/A/${enc_name}"

     resp=$(curl --connect-timeout 10 --max-time 30 -s -X POST "$api" \
                 -H "Content-Type: application/json" \
                 -d "{
                     \"apikey\": \"${apikey}\",
                     \"secretapikey\": \"${secretapikey}\",
                     \"content\": \"${ipv4}\",
                     \"ttl\": \"${ttl}\"
                    }")
     [ "$resp" = '{"status":"SUCCESS"}' ]
 }

 ################################################################################

 case "$1" in
     "" ) verbose=1 ;;
     -s ) ;;
     -h|* ) help ;;
 esac

 ipv4=$(myip)
 ipv4_regex="^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}\
(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b"

 if ! printf "%s" "${ipv4}" | grep -Eq "$ipv4_regex"; then
     fatal "Could not determine public IP address."
 fi

 if ! mkdir -p /var/db/dnsup; then
     fatal "Failed to create /var/db/dnsup."
 fi

 for cfg in /etc/dnsup/*.conf /usr/local/etc/dnsup/*.conf; do

     unset apikey domain ipv4_file ls_ipv4 name pat provider secretapikey \
           success ttl

     [ -f "$cfg" ] || continue
     . "${cfg}"

     name=${name:=@}
     provider=$(printf "%s" "${provider}" | tr '[:upper:]' '[:lower:]')
     ipv4_file="/var/db/dnsup/${provider}_${name:+${name}.}${domain}"
     ls_ipv4=$(grep -E "$ipv4_regex" "$ipv4_file" 2>/dev/null) # last sent IP

     if [ "${ipv4}" != "${ls_ipv4}" ]; then
         case ${provider} in
             'gandi')
                 gandi && success=true
                 ;;
             'porkbun')
                 porkbun && success=true
                 ;;
             *)
                 fatal "DNS provider is not supported."
         esac
         if [ -n "$success" ]; then
             tmpfile="${ipv4_file}.tmp"
             printf "%s" "${ipv4}" > "${tmpfile}" && mv -f "${tmpfile}" "${ipv4_file}"
             [ -n "${verbose}" ] && \
                 printf "[%s] %s: Updated A record from %s to %s.\n" "$(date)" "${domain}" "${ls_ipv4:-?}" "${ipv4}"
         else
             fatal "${domain}: API update failed. Response: ${resp}"
         fi
     else
         [ -n "${verbose}" ] && \
             printf "[%s] %s: External IP address is still %s.\n" "$(date)" "${domain}" "${ls_ipv4}"
     fi
 done
