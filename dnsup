#!/bin/sh
#
# SPDX-License-Identifier: BSD-2-Clause
#
# Copyright (c) 2016-2025, Joe Mingrone.
#

# dnsup - DNS Updater
#
# Run dnsup -h or visit https://github.com/Jehops/dnsup for an overview.
#

fatal ()
{
    printf "[%s] FATAL: $*\n" "$(date)" > /dev/stderr
    exit 1
}

help () {
    readonly version=0.5

    cat <<EOF
NAME
   ${0##*/} -- DNS Updater

SYNOPSIS
   ${0##*/} [-h|-s]

DESCRIPTION
   Update a host's A record when its external IPv4 address changes.  The update
   is performed using a DNS provider's API.  Gandi, GoDaddy, and Porkbun are
   supported.

   -h   Print this help message.
   -s   Be silent except upon error.

   A configuration file, typically named <domain>.<record>.conf (e.g.,
   home.example.com.conf), is read from /etc/dnsup/ or /usr/local/etc/dnsup/ for
   each A record to be updated.

   Configuration values

   Common:
   provider=<Gandi | GoDaddy | Porkbun>
   domain=<domain name>
   name=<Use @ or leave blank for zone root, otherwise subdomain without domain>
   ttl=<TTL in seconds, minimum of 600 for Porkbun>

   Gandi:
   pat=<Personal Access Token>

   Godaddy:
   key=<API key>
   secret=<API key secret>

   Porkbun:
   apikey=<API key>
   secretapikey=<secret API key>

   To learn about the API keys and configuration values specific to each
   provider, visit these sites.

   Gandi: https://api.gandi.net/
   GoDaddy: https://developer.godaddy.com
   Porkbun: https://porkbun.com/account/api

COMPATIBILITY
   ${0##*/} is written in POSIX shell.  It requires curl with TLS support and a
   CA certificate store.

EXAMPLE
   $ cat /etc/crontab

   PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin
   SHELL=/bin/sh

   #minute  hour  mday  month  wday  who    command
   */5      *     *     *      *     dnsup  dnsup >> /var/log/dnsup.log 2>&1
   @reboot                           dnsup  dnsup >> /var/log/dnsup.log 2>&1

AUTHOR
Joe Mingrone <jrm@ftfl.ca>

VERSION
   ${0##*/} version ${version}

EOF
    exit 0
}

url_encode() {
   # Encode all characters except alphanumerics and -._~
   old_lc_collate=$LC_COLLATE
   LC_COLLATE=C
   input=$1
   encoded=""
   i=1
   len=$(printf "%s" "$input" | wc -c)
   while [ "$i" -le "$len" ]; do
       c=$(printf "%s" "$input" | cut -c $i)
       case "$c" in
           [a-zA-Z0-9.~_-]) encoded="${encoded}${c}" ;;
           *) encoded="${encoded}$(printf '%%%02X' "'$c")" ;;
       esac
       i=$((i + 1))
   done
   LC_COLLATE=$old_lc_collate
   printf "%s" "$encoded"
}

myip () {
    host myip.opendns.com resolver1.opendns.com | \
            awk '/^myip.opendns.com has address / {print $4}'
}

gandi () {
    api='https://api.gandi.net/v5/livedns/domains/'

    resp=$(curl --connect-timeout 10 --max-time 30 -L -s -X PUT \
                -H "Authorization: Bearer $pat " \
                -H "Content-type: application/json" \
                -d '{"rrset_values": ["'"$ipv4"'"],"rrset_ttl": '"${ttl}"'}' \
                "${api}/${domain}/records/${name}/A")

    [ "$resp" = '{"message":"DNS Record Created"}' ]
}

godaddy () {
    api='https://api.godaddy.com/v1/domains/'

    resp=$(curl --connect-timeout 10 --max-time 30 -L -s -X PUT \
                -w '%{http_code}' \
                -H "Authorization: sso-key ${key}:${secret}" \
                -H "Content-type: application/json" \
                -d "[ {\"data\":\"${ipv4}\",\"ttl\":${ttl}} ]" \
                "${api}${domain}/records/A/${name}")

    [ "$resp" = "200" ]
}

porkbun () {
    enc_domain=$(url_encode "${domain}")
    enc_name=$(url_encode "${name}")
    api="https://api.porkbun.com/api/json/v3/dns/editByNameType/${enc_domain}/A/${enc_name}"

    resp=$(curl --connect-timeout 10 --max-time 30 -s -X POST "$api" \
                -H "Content-Type: application/json" \
                -d "{
                     \"apikey\": \"${apikey}\",
                     \"secretapikey\": \"${secretapikey}\",
                     \"content\": \"${ipv4}\",
                     \"ttl\": \"${ttl}\"
                    }")
    [ "$resp" = '{"status":"SUCCESS"}' ]
}

if [ $# -gt 1 ] || { [ $# -eq 1 ] && [ "$1" != '-s' ]; }; then
    help
elif [ $# -eq 0 ]; then
    verbose=1
fi

################################################################################

ipv4=$(myip)
ipv4_regex="\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}\
(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b"

if ! printf "%s" "${ipv4}" | grep -Eq "$ipv4_regex"; then
    fatal "Could not determine public IP address."
fi

for cfg in /etc/dnsup/*.conf /usr/local/etc/dnsup/*.conf; do
    unset apikey domain ipv4_file key ls_ipv4 name pat provider secret \
          secretapikey success ttl

    [ -e "$cfg" ] || continue
    [ -f "$cfg" ] || continue

    . "${cfg}"
    name=${name:=@}
    provider=$(printf "%s" "${provider}" | tr '[:upper:]' '[:lower:]')
    ipv4_file="/var/db/dnsup/${provider}_${name:+${name}.}${domain}"
    ls_ipv4=$(grep -E "$ipv4_regex" "$ipv4_file" 2>/dev/null) # last sent IP

    if [ "${ipv4}" != "${ls_ipv4}" ]; then
        case ${provider} in
            'gandi')
                gandi && success=true
                ;;
            'godaddy')
                godaddy && success=true
                ;;
            'porkbun')
                porkbun && success=true
                ;;
            *)
                fatal "DNS provider is not supported."
        esac
        if [ -n "$success" ]; then
            printf "%s" "${ipv4}" > "${ipv4_file}"
            [ -n "${verbose}" ] && \
                printf "[%s] ${domain}: Updated A record from ${ls_ipv4:-?} to ${ipv4}.\n" "$(date)"
        else
            printf "%s\\n" "${resp}"
        fi
    else
        [ -n "${verbose}" ] && \
            printf "[%s] ${domain}: External IP address is still ${ls_ipv4}.\n" "$(date)"
    fi
done
